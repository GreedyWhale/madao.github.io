这是一篇学习笔记，学习的课程是饥人谷方应杭老师的 React 造轮子课程，虽然很早就买了课，但是一直没看，今年也快要结束了，感觉什么也没干，所以 flag 立起来，今年结束之前看完所有买的课程。

![](/caisr.github.io/database/images/articles/react/functionalProgramming/image.jpg)

### 函数式编程

一提到 React，伴随它的关键词中一定会有“函数式编程”这个关键词，但实际上我到现在都对这个概念很模糊，不能清晰的描述出来，这节课是运用到了《SICP》这本书中的一些知识点，结合这本书 + 这节课看看能不能搞懂。

#### 1. Lisp

先简单了解一下 Lisp 这门语言，因为 List 是第一个函数式程序语言，所以我们通过它来理解函数式编程，仅仅需要知道最简单的几个语法：

1.  四则运算
    - 加法
      `(+ 1 2)`
    - 减法
      `(- 10 1)`
    - 乘法
      `(* 10 5)`
    - 除法
      `(/ 8 4)`
2.  定义一个变量
    `(define name madao)`
3.  定义一个函数

    ```
    (define add (x y)
         (+ x y))
    ```

    _注意_：你如果去在线的 Lisp 编译器上执行上面代码会报错`EVAL: undefined function DEFINE`，我在 stackoverflow 上找到了这样的答案：

    > define is not a part of the ANSI Common Lisp language which is implemented by GNU CLISP (I think you are confusing CL with Scheme).
    >
    > When defining a variable, use defvar, for a function use defun.
    >
    > You might want to get a book, e.g., ANSI Common Lisp.

    [原文地址](https://stackoverflow.com/questions/31346880/eval-undefined-function-define)

    简单说就是定义变量用`defvar`，定义函数用`defun`，至于为什么他也说了*I think you are confusing CL with Scheme*，我尝试去搜索 CL 和 Scheme 的区别（我也不知道 CL 是什么的缩写），大概看了下决定就此打住，等有空再说吧...

4.  组合式的求值
    组合式就是组合起来的表达式，比如：

    ```
    (* (+ 1 2) (- 10 5))
    ```

    要求值一个组合式，需要做到以下两点：

    1. 将组合式的各个子表达式的值求出来
    2. 将各个子表达式的值应用到最左边的运算符

    用上面的例子解释就是，先算出`(+ 1 2)` 和 `(- 10 5)`的值，然后将它们的值`*`起来，同样在算`(+ 1 2)` 和 `(- 10 5)`的时候也是这样的。

    根据上面的概念可以看出，一个复杂的组合式求值过程就是不断的对组合式中的各个子表达式执行同样的求值过程，这个过程是**递归**的，所以这种求值也叫递归求值。

    再复杂一点：

    ```
    ;;求平方的函数
    (define (square x) (* x x))
    ;;求平方和的函数
    (define (sun-of-square x y)
      (+ (square x) (square y)))
    ;;定义一个函数
    (define (f a)
      (sum-of-square (+ a 1) (+ a 2)))
    ```

    现在要求 `(f 5)`，试着写出这个组合式的求值过程，书中对这个过程有这样的描述：

    > 将复合过程（其运算符是一个复合过程的名字）应用于实际参数，就是再将过程体中的每个形参用相应的实参取代后，对这一过程体求值

    这里吐槽一下，这种专业书总是搞些让人似懂非懂的专业名词，但是用自己的词汇又表达不出来这种意思，很气。

    好了，用伪代码说明：

    ```
    (f 5)
    ;;提取出f的函数体
    (sun-of-square (+ a 1) (+ a 2))
    ;;再用实参5代换形参a
    (sun-of-square (+ 5 1) (+ 5 2))
    ;;这时候用到之前说的递归求值，从要算出组合式的各个子表达式的值，然后应用到最左边的运算符
    ;;这里的运算符并不是`*、+、-、/`这些内部基本的过程，它本身就是一个组合式，所以也要对它进行求值
    ;;将sun-of-square进行代换，然后计算(+ 5 1)和(+ 5 2)，得到的值进行实参和形参的代换
    (+ (square 6) (square 7)
    ;;继续上面的步骤
    (+ (* 6 6) (* 7 7)
    (+ 36 49)
    85
    ```

    这种计算过程成为过程应用的**代换模型**，实际的工作原理并不一定是这样的，代换模型只是为了让我们更好的理解过程调用中的情况。

    如果你坚持看到这里，你大概和我一样已经开始晕了，没有一个字提到函数式编程，而且东扯西扯的扯了一堆概念，先停下只要记住两个概念：

    1. 组合式的求值过程是：计算出各个子表达式，将子表达式的值应用于最左边的操作符，这一过程是递归的。
    2. 操作符本身也有可能是组合式，当操作符本身是组合式的情况下利用代换模型将运算符进行代换，然后在利用递归求值进行计算，得出最终的值。

    书中还提到了一个概念**正则序**和**应用序**，直接通过代码理解吧：

    1. 正则序
       完全展开后归约的求值模型称为**正则序求值**
       ```
       (f 5)
       (sun-of-square (+ 5 1) (+ 5 2))
       (+ (square (+ 5 1)) (square (+ 5 2)))
       (+ (* (+ 5 1) (+ 5 1)) (* (+ 5 2) (+ 5 2)))
       (+ (* 6 6) (* 7 7))
       (+ 36 49)
       85
       ```
    2. 应用序
       先求值参数而后应用的方式，成为**应用序求值**
       ```
       (f 5)
       (sun-of-square (+ a 1) (+ a 2))
       (sun-of-square (+ 5 1) (+ 5 2))
       (+ (square 6) (square 7)
       (+ (* 6 6) (* 7 7)
       (+ 36 49)
       85
       ```
       最明显的区别就是正则序求值中存在重复的计算，Lisp 采用的是应用序求值

5.  递归和迭代
    用阶乘来举例，如何描述出阶乘的计算过程？其中一种是这样的

    - `n!`等于`n`乘以`(n - 1)!`，如果我们能用语言描述出计算过程，那么就可以转换成代码：
      ```
      (define (factorial n)
        (if (= n 1)
          1
          (* n (factorial (- n 1)))))
      ```
      它的计算过程就是这样的
      ```
      (factorial 6)
      (* 6 (factorial 5))
      (* 6 (* 5 (factorial 4)))
      (* 6 (* 5 (* 4 (factorial 3))))
      (* 6 (* 5 (* 4 (* 3 (factorial 2)))))
      (* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
      (* 6 (* 5 (* 4 (* 3 (* 2 1)))))
      (* 6 (* 5 (* 4 (* 3 2))))
      (* 6 (* 5 (* 4 6)))
      (* 6 (* 5 24))
      (* 6 120)
      720
      ```
      这样一看递归这个命名就非常适合了，先递进，再回归
    - 另外一种是这样的，`n! = 1 * 2 * ... * (n - 1) * n`，正好和上面那种描述相反，这种描述有几个关键点，当前的计算的结果，当前的计算次数，最大的计算次数，现在转换成代码：

      ```
      (define (factorial current-value, current-count, max-count)
        (if (> current-count max-count)
          current-value
          (factorial (* current-value current-count)
                     (+ current-count 1)
                     max-count)))
      ```

      那么它的计算过程是这样的：

      ```
      (factorial 1 1 6)
      (factorial 1 2 6)
      (factorial 2 3 6)
      (factorial 6 4 6)
      (factorial 24 5 6)
      (factorial 120 6 6)
      (factorial 720 7 6)
      ```

      和递归计算过程相比迭代计算过程没有回归这一步骤，每次计算的结果会用作下次计算。

6.  高阶函数
    上面有简单的说递归计算过程，就是为了更好的理解高阶函数这个概念，先看下维基百科上对高阶函数的定义：

    > 在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数：
    >
    > - 接受一个或多个函数作为输入
    > - 输出一个函数

    上面例子中的`factorial`函数就是一个高阶函数

    再来通过一个例子加深理解：

    ```
     ;;计算a到b之间的各个整数和
     (define (sum-int a)
       (if (> a b)
         0
         (+ a (sum-int (+ a 1) b))))
     ;;计算a到b之间的各个整数平方和
     (define (square x) (* x x))
     (define (sum-int-square a b)
       (if (> a b)
         0
         (+ (square a) (sum-int-square (+ a 1) b))))
     ;;计算a到b之间的各个整数立方和
     (define (cube x) (* x x x))
     (define (sum-int-cube)
       (if (> a b)
         0
         (+ (cube a) (sum-int-cube (a + 1) b))))
    ```

    仔细观察上面的函数，它们有很多相似的地方，可以写成一个模版

    ```
    (define (<name> a b)
     (if (> a b)
       0
       (+ (<term> a) (<name> (<next> a) b))))
    ```

    用这个模版创建一个函数：

    ```
    (define (sum term a next b)
     (if (> a b)
       0
       (+ (term a) (sum term (next a) next b))))
    ```

    其中`term、 a、 next、 b`这四个都是形参名，因为它的形参名之间没有分隔符，感觉挺难读的。

    将上面三个函数改写一下就是：

    ```
     (define (add-one x) (x + 1)) ;;返回x+1对应模版中的next形参
     (define (constant x) (x)) ;;返回x原本的值对应模版中的term形参
     (define (square x) (* x x)) ;;返回x的平方值对应模版中的term形参
     (define (cube x) (* x x x)) ;;返回x的立方值对应模版中的term形参

     (define (sum-int a b)
       (sum constant a add-one b))

     (define (sum-int-square a b)
       (sum square a add-one b))

     (define (sum-int-cube a b)
       (sum cube a add-one b))
    ```

    这样一抽象代码就变得简洁许多，不过个人感觉有点绕，得思考一下才能读懂。

#### 2. 那么到底什么是函数式编程

上面扯了一堆的概念但是并没有说到什么是函数式编程，如果你有搜索一些讲函数式编程的文章
那么它一定有说函数式编程，具有下面这几个特点：

1. 函数是"第一等公民"，可以作为其他函数的参数或返回值，可以赋值给其他变量
2. 函数没有“副作用”，函数不会在函数外部更改任何变量或任何类型的数据，它的返回值仅取决于输入参数，只要参数不变，返回值就不变
3. 不可变性，变量声明后，就不允许再修改它，变量只是值的名称
4. 引用透明，程序中任意两处具有相同输入值的函数调用能够互相置换，而且不会产生副作用，也就是说函数的返回的值不会受到调用位置，调用次数，以及什么时候调用的影响。

我觉得其中最最重要的是**不可变性**，仔细理解上面 1，2，4 这三个特点，发现它们最终的目的都是为了实现不可变性这一目的

不可变性这一特点带来的其他问题就是，不能再用类似于 js 中的 for、while、do...while 这些循环语句，
因为这些语句都需要一个可变的状态作为循环的计数器，函数式编程通过递归实现循环，递归有一个明显的问题就是调用嵌套太深非常消耗性能，甚至会出现栈溢出的情况
再看上面的中的递归和迭代的例子，将递归的计算过程优化成迭代的计算过程就会避免递归导致的性能降低、栈溢出的问题，这个优化也叫尾递归，我之前一直以为迭代就是尾递归，但是看了《SICP》中的这一段描述后发现不是一回事：

> 在做迭代和递归之间的比较时，我们必须当心，不要搞混了“递归计算过程”的概念和“递归过程”的概念。
> 当我们说一个过程是递归的时候，论述的是一个语法形式上的事实，说明这个过程的定义中（直接或间接地）引用了改过程本身

我是这样理解这段话的，用上面递归和迭代中的例子说明，就是 factorial 的迭代版本它实际上还是递归过程，因为它符合递归的定义（指在函数的定义中使用函数自身的方法）,虽然它是递归的过程但是“计算过程”却是迭代的计算过程。

#### 3. 引进赋值的代价

函数式编程强调“不可变性”，意味着一个变量声明后就不能再对它进行赋值操作了，赋值到底有什么问题呢？
《SICP》中说到：

> 赋值操作使我们的程序设计语言不能在用代换模型解释了。进一步说任何具有“漂亮”数学性质的简单模型，都不可能继续适合作为处理程序设计语言里的对象和赋值的框架了。

这段话前半部分还能理解，后面就理解不了了，我目前的理解就是，如果可以赋值，同样的函数，同样的参数，得到的结果却不同，这样会导致数学体系在程序设计语言里不适用了

> 只要我们不使用赋值，以同样的参数对同一过程的两次求值一定产生出同样的结果，因此就可以认为过程是在计算数学函数。不用任何赋值的程序设计称为函数式程序设计
